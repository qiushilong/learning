# 原型

## [[Prototype]]

在 JavaScript 中，对象有一个特殊的隐藏属性 [[Prototype]] ，它要么为 null，要么就是对另一个对象的引用。该对象被称之为 ”原型“。



## 原型继承

当我们从一个对象中读取一个缺失的属性时，JavaScript 会自动尝试从原型中获取该属性，这被称为”原型继承“。

```js
let animal = {
  eats: true,
};
let rabbit = {
  jumps: true,
}

// [[Prototype]] 是内部的而且是隐藏的，可以通过设置 __proto__ 来指定原型
rabbit.__proto__ = animal;

console.log(rabbit.eats); // true
```

在这里，我们称 rabbit 的原型是 animal，eats 是 rabbit 从 animal 中通过原型继承而来。



## 原型链

当原型相互串联，就形成了原型链。

```js
let animal = {
  eats: true,
  walk(){
    console.log("Animal Walk");
  },
}

let rabbit = {
  jump: true,
  __proto__: animal,
}

let longEar = {
  earLength: 10,
  __proto__: rabbit,
}

longEar.walk(); // Animal Walk
```

**注意：**

- 引用不能形成闭环。如果我们试图在一个闭环中分配 \_\_proto\_\_ ，JavaScript 会抛出一个错误。
- \__proto__ 的值可以是可以是对象，也可以是 null。其他类型都会被忽略。
- \_\_proto\_\_ 是 [[Prototype]] 因历史原因留下来的 getter/setter。现代编程语言建议我们使用 Object.getPrototypeOf/Object.setPrototypeOf 来取代 \__proto__ 操作原型。



##   for in

```js
let animal = {
  eats: true
}

let rabbit = {
  jumps: true,
  __proto__: animal
}

console.log(Object.keys(rabbit)); // ['jumps']

for(let prop in rabbit) console.log(prop); // jumps eats 

for(let prop in rabbit) {
  rabbit.hasOwnProperty(prop) && console.log(prop); // jumps
}
```

- for in 会获取 rabbit 的所有可枚举的属性名，包括继承的属性。
- rabbit.hasOwnProperty() 可以判断属性是否是继承得来的。
- hasOwnProperty 来自 Object.prototype.hasOwnProperty。
- hasOwnProperty 没有出现在 for in 中，因为 hasOwnProperty 是不可枚举的，即有 enumerable: false 标志。
- Object.keys()，Object.values()，Object.entries() 都会忽略继承的属性。



## 🌰

```js
let hamster = {
  stomach: [],
  
  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
}

speedy.eat('apple');
console.log(speedy.stomach); // apple
console.log(lazy.stomach); // apple
```



# 函数原型

每个函数都会有 “prototype” 属性，即使我们没有提供它。

默认的 “prototype” 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。

```js
function Rabbit() {}

/*
Rabbit.prototype = { constructor: Rabbit };
*/

const flag = Rabbit.prototype.constructor === Rabbit;
console.log(flag); // true
```

constructor 属性可以通过 [[Prototype]] 传递下去

```js
function Rabbit(){}

let rabbit = new Rabbit();

console.log(rabbit.constructor === Rabbit); // true
```



我们可以使用 constructor 属性来创建一个新对象，该对象使用与现有对象相同的构造器。

```js
function Rabbit(name){
  this.name = name;
  console.log(name);
}

let rabbit = new Rabbit("White Rabbit");

let rabbit2 = new rabbit.constructor("Black Rabbit");
```



JavaScript 自身并不能保证正确的 “constructor” 函数值。

```js
function Rabbit(){}
Rabbit.prototype = {
  jumps: true,
}

let rabbit = new Rabbit();
console.log(rabbit.constructor === Rabbit); // false
```



因此，为了保证正确的 “constructor”，我们可以选择添加/删除属性到默认 “prototype”，而不是将其整个覆盖。

```js
function Rabbit(){}


```

