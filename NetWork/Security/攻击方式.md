# 攻击方式

## XSS（Cross-Site Scripting）

跨站脚本攻击是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击这登录网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session，tokens，或者其他敏感信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。

XSS 攻击的本质是：恶意代码未经过滤，与网站正常的代码混在一起。浏览器无法分辨那些脚本是可信的，导致恶意脚本执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。

### **可能造成的影响**

- 利用虚假输入表单骗取用户个人信息。

- 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。

- 显示伪造文章或者图片。

  

### 反射型 XSS

当用户点击一个恶意连接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。

#### 步骤

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开大有恶意代码的 URL 时，网站服务器端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接受到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户的行为，调用目标接口执行攻击者指定的操作。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索，跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

#### 防范

对字符串进行编码，将 url 转义再输出到界面。



### DOM 型 XSS

DOM 型 XSS 攻击，实际上就是前端 javascript 代码不够严谨，把不可信的内容插入到了页面。使用 .innerHtml，.outerHtml，appendChild，document.write() API 时要特别消息，不要把不可信的数据作为 HTML 插入到界面，尽量使用 .innerText，.textContext，.setAttribute等。

#### 步骤

1. 攻击者构造出特殊数据，其中包含恶意代码。
2. 用户浏览器执行了恶意代码。
3. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口进行攻击者指定的操作。

#### 防范

对字符串进行编码，将 url 进行转义。



### 存储型 XSS

恶意脚本永久存储再目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和 DOM 型大。存储型 XSS 攻击的原因仍然是没有做好数据过滤：前端提交数据至服务器时，没有做好过滤；服务器接受到数据时，在存储之前，没有做过滤；前端从服务器请求到数据，没有过滤输出。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。

经历：有一次点掘金跳到其他网站去了。

#### 步骤

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务器将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

#### 防范

1. 前端传递数据给服务器之前，先进行转义/过滤。
2. 服务器接受数据后，存储之前，先进行转义/过滤。
3. 前端接收到服务器传递过来的数据，在展示之前，先进行转义/过滤。



### 其他防范手段

仅仅简单粗暴的去掉 script 标签是没有用的，任何合法的 HTML 标签都可以添加 onClick 一类的属性来执行 javascript。

#### Content Security Policy

服务端使用 HTTP Content-Security-Policy 头部来指定策略，或者在前端设置 meta 标签。

配置只允许加载同域下的资源。

```
Content-Security-Policy: default-src 'self'
```

```html
<meta http-equiv="Content-Security-Policy" content="form-action 'self';"
```

严格的 CSP 在 XSS 的防范中可以起到一下作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄漏到外域。
- 禁止内联脚本执行。
- 禁止未授权的脚本执行。
- 合理使用上报可以即使发现 XSS，利于尽快修复问题。

#### 输入内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但是可以增加 XSS 攻击的难度。

#### 输入内容限制

对于部分输入，可以限制不能包含特殊字符或者仅能输入数字等。

#### HTTP-only Cookie

禁止 javascript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。

#### 验证码

防止脚本冒充用户提交危险操作。



### XSS 检测

1. 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。

2. 使用第三方工具。



## CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### 攻击流程

1. 受害者登录 A 站点，并保留了登录凭证（Cookie）。
2. 攻击者诱导受害者访问了站点 B。
3. 站点 B 向 站点 A 发送了一个请求，浏览器会默认携带站点 A 的 Cookie 信息。
4. 站点 A 收到请求后，对请求进行验证，并确定是受害者的凭证，误以为是无辜的受害者发送的请求。
5. 站点 A 以受害者的名义执行了站点 B 的请求。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。

![](D:\learn\DDU\NetWork\Security\img\CSRF.jpg)

### 特点

1. 攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。
2. 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息（cookie有同源策略）。
3. 跨站请求可以用各种方式：图片URL，超链接，CORS，Form提交等等（来源不明的链接，不要点击）。

### 防御

#### 添加验证码

验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验就会非常差。但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。

#### 判断请求的来源 -- 检测Referer

referer标识请求来自哪个网址。referer可以作为一种辅助手段，来判断请求的来源是否安全，但是referer本身是可以修改的，所以不能完全依赖referer。

#### 使用Token

CSRF攻击之所以可以成功，是因为服务器误把攻击者发送的请求当成了自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过验证请求是否携带正确的Token，来吧正常的请求和攻击的请求分开。跟验证码类似，只是用户无感知。

- Token 要足够随机，使攻击者无法准确预测。
- Token 要是一次性的，及每次请求成功后要更新 Token，增加预测难度。
- Token 要主要保密性，敏感操作使用 POST，防止Token出现在URL中。

#### Samesite Cookie属性

Samesite=Strict 被称为是严格模式，表明这个Cookie在任何情况下都不能作为第三方的Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下对A站点的任何请求，都不会携带cookie到请求中。



## 点击劫持