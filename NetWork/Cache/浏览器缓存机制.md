## 浏览器缓存机制

#### 匹配流程

1. 浏览器发送请求前，根据请求头的 expires 和 cache-control 判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存中获取资源，并不会发送请求。如果没有命中，则进入下一步。
2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的 last-modified 和 etag 判断是否命中协商缓存，如果命中，直接从缓存中获取资源。如果没有命中，则进入下一步。
3. 如果前两部都没有命中，则直接从服务器获取资源。



#### 强缓存

##### 定义

不会向服务器发送请求，直接从缓存中读取资源。

##### 原理

强缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强缓存的的情况主要有三种，如下。

- 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求。

![](.\img\强缓存1.jpg)

- 存在缓存标识和缓存结果，但是已经失效，强缓存失效，则使用协商缓存（暂不分析）

![](.\img\强缓存2.jpg)

- 存在改缓存标识和缓存结果，且改结果没有失效，强制缓存生效，直接返回结果。

![](.\img\强缓存3.jpg)

##### 规则

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头和请求结果一个返回给浏览器，控制强缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。



##### Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，无需再次请求。

**注意：**Expires 是 HTTP/1.0 的产物，受限于本地时间，如果修改了本地时间，可能会导致缓存失效。



##### Cache-Control

在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：

- public：所有内容都将被缓存（客户端和代理服务器都可以缓存）。
- private：所有内容只有客户端可以缓存，Cache-Control 的默认取值。
- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定。
- no-store：所有内容都不会被缓存，既不使用强缓存和协商缓存。
- max-age=xxx（xxx is numeric）：缓存内容将在 xxx 秒后失效。

**注意：**需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确定一下数据是否还跟服务器保持一致，也就是协商缓存。而 no-store 才表示不会被缓存。



##### 设置

强缓存需要服务端设置 expires 和 cache-control。

nigix 代码参考，设置了一年的缓存时间：

```nginx
location ~ .*.(ico|svg|ttf|eot|woff)(.*){
    proxy_cache					pnc;
    proxy_cache_valid			200 304 1y;
    proxy_cache_valid			any 1m;
    proxy_cache_lock			on;
    proxy_cache_lock_timeout	5s;
    proxy_cache_use_stale       updating error timeout invalid_header http_500 http_502;
    expires						1y;
}
```



##### 缓存存储位置

- from memory cache（内存缓存）：不请求网络资源，资源在内存中，一般脚本，字体，图片会存在内存当中。
- from disk  cache（磁盘缓存）：不请求网络资源，资源在磁盘中，如 css 等。

浏览器读取缓存的顺序：memory -> disk。

查看资源来自缓存还是服务器：F12 -> NetWork -> 每一项的 size



#### 协商缓存

##### 定义

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

##### 原理

- 协商缓存生效，返回 304 和 Not Modified。

![](.\img\协商缓存1.jpg)

- 协商缓存失效，返回 200 和请求结果。

![](.\img\协商缓存2.jpg)

##### Last-Modified 和 If-Modified-Since

1. 浏览器首先发送一个请求，让服务器在响应头中返回请求的资源上次更新时间，就是 last-modified，浏览器会缓存下这个时间。
2. 然后浏览器在下次请求中，请求头中带上 if-modified-since:[保存的 last-modified  值]。根据浏览器发送的修改时间和服务端的修改时间进行比较，一致的话标识资源没有变化，服务端返回正文为空的响应，让浏览器从缓存中读取资源，这就大大减少了请求的消耗。

由于 last-modified 以来的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位，1秒内多次修改是无法捕捉到的。
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用 etag。



##### ETag 和 If-None-Match

etag 是 http 协议提供的若干机制中的一种 web 缓存验证机制，并且允许客户端进行缓存协商。生成 etag 常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。和 last-modified 一样。

- 浏览器会向发送一个请求得到 etag 的值，然后在下一次请求的请求头上带上 if-none-match:[保存的 etag 值]。
- 通过发送的 etag 的值和服务端重新生成的 etag 值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

##### 对比

etag 能够解决 last-modified 的一些缺点，但是 etag 每次服务端生成都需要进行读写操作，而 last-modified 只需要读取操作，从这方面来看，etag 的消耗更大。

- 精确度上：etag 优于 last-modified
- 优先级上：先考虑 etag
- 性能上：last-modified 优于 etag



#### 用户行为对浏览器缓存的影响

1. 打开网页，地址栏输入地址，查找 disk cache 中是否有匹配。如果有则使用，如果没有发送网络请求。
2. 普通刷新（f5）：因为 Tab 并没有关闭，因此 memory cache 是可用的，会被优先使用（如果匹配的话）。其次才是 disk cache。
3. 强制刷新（ctrl + f5）：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache（为了兼容，还带了 Pragma: no-cache），服务器全都返回 200 和最新内容。