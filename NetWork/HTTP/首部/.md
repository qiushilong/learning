# HTTP 首部
HTTP 协议的请求和响应报文中必定包含 HTTP 首部

## HTTP 请求报文
请求方法 URI HTTP版本
请求首部字段
通用首部字段
实体首部字段
CRLF
请求体

## HTTP 响应报文
HTTP版本 状态码 状态码说明
响应首部字段
通用首部字段
实体首部字段
CRLF
响应体

## HTTP 首部字段结构
HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号":"分隔
> 首部字段名: 字段值

例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的对象类型。
> Content-Type: text/html

就以上示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。

另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。
> Keep-Alive: timeout=15, max=100

首部字段重复的情况下，并没有明确的使用关系，跟随浏览器的不同表现不同。

## 四种 HTTP 首部字段类型
HTTP 首部字段根据实际用途被分为一下 4 种类型。

- 通用首部字段（General Header Fields）
    请求报文和响应报文都会使用的首部。
- 请求首部字段（Request Header Fields）
    从客户端向服务器发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
- 响应首部字段（Response Header Fields）
    从服务器端详客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
- 实体首部字段（Entity Header Fields）
    针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有光的信息。

## HTTP/1.1 首部一览

### 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

### 请求首部字段

| 首部字段名          | 说明                                            |
| ------------------- | ----------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                        |
| Accept-Charset      | 优先的字符集                                    |
| Accpet-Encoding     | 优先的内容编码                                  |
| Accpet-Language     | 优先的语言（自然语言）                          |
| Authorization       | Web 认证信息                                    |
| Expect              | 期待服务器的特定行为                            |
| From                | 用户的电子邮件地址                              |
| Host                | 请求资源所在服务器                              |
| If-Match            | 比较实体标记（ETag）                            |
| If-Modified-Since   | 比较资源的更新时间                              |
| If-None-Match       | 比较实体标记（与 If-Match 相反）                |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards        | 最大传输逐跳数                                  |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                  |
| Range               | 实体的字节范围请求                              |
| Referer             | 对请求中 URI 的原始获取方                       |
| TE                  | 传输编码的优先级                                |
| User-Agent          | HTTP 客户端程序的信息                           |

### 响应首部字段
| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

### 实体首部字段
| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的 HTTP 方法 |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体的自然语言         |
| Content-Location | 代替对应资源的 URI     |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置范围     |
| Content-Type     | 实体主体的媒体类型     |
| Expires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改日期时间 |

### 非 HTTP/1.1 首部字段
| 首部字段名          | 说明 |
| ------------------- | ---- |
| Cookie              |      |
| Set-Cookie          |      |
| Content-Disposition |      |

## End-to-end 首部和 Hop-by-hop 首部
HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成两种类型。

- 端到端首部（End-to-end Header）
分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须转发。
- 逐跳首部（Hop-by-hop Header）
分在此类别中的首部支队单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

逐跳首部（8 个）：
- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade


---
通用首部字段

## Cache-Control
操作缓存的工作机制。

指令的参数是可选的，多个指令之间通过 “,” 分隔。首部字段 Cache-Control 的指令可用于请求以及响应时。
> Cache-Control: private, max-age=0, no-cache

### 缓存请求指令
| 指令             | 参数   | 说明                         |
| ---------------- | ------ |
| no-cache         | 无     | 强制向源服务器再次验证       |
| no-store         | 无     | 不缓存请求或响应的任何内容   |
| max-age=[秒]     | 必须   | 响应的最大 Age 值            |
| max-stale(=[秒]) | 可省略 | 接受已过期的响应             |
| min-fresh=[秒]   | 必须   | 期望在指定时间内的响应仍有效 |
| no-transform     | 无     | 代理不可更改媒体类型         |
| only-if-cached   | 无     | 从缓存获取资源               |
| cache-extension  | -      | 新指令标记（token）          |

### 缓存响应指令

| 指令             | 参数   | 说明                                           |
| ---------------- | ------ | ---------------------------------------------- |
| public           | 无     | 可向任意方提供响应的缓存                       |
| private          | 可省略 | 仅向特定用户返回响应                           |
| no-cache         | 可省略 | 缓存前必须先确定其有效性                       |
| no-store         | 无     | 不缓存请求或响应的任何内容                     |
| no-transform     | 无     | 代理不可更改媒体类型                           |
| must-revalidate  | 无     | 可缓存但必须再向源服务器进行确定               |
| proxy-revalidate | 无     | 要求中间缓存服务器对缓存的响应有效性在进行确定 |
| max-age=[秒]     | 必须   | 响应的最大 Age 值                              |
| s-maxage=[秒]    | 必须   | 公共缓存服务器响应的最大 Age 值                |
| cache-extension  | -      | 新指令标记（token）                            |

### 表示是否能缓存的指令
#### public
> Cache-Control: public

当指定使用 pulic 指令时，则明确表明其他用户也可利用缓存。

#### private
> Cache-Control: private

当指定使用 private 指令时，响应只以特定的用户作为对象，这与 public 指令的行为相反。
缓存服务器会对该特定用户提供资源缓存的服务，对其他用户发送过来的请求，代理服务器则不会返回缓存。

#### no-cache
> Cache-Control: no-cache
使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。

客户端发送的请求中如果包含 no-cache 指令，表示客户端将不会接受缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。

如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对资源服务器请求中提出的资源有效性进行确定，且禁止其对响应资源进行缓存操作。

### 控制可执行缓存的对象指令
#### no-store
> Cache-Control: no-store

当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。
因此，该指令规定缓存不能在本地存储请求或响应的任一部分。

比较 no-cache
- no-cache 表示不缓存过期的资源，缓存会向源服务器进行有效期确定后处理资源。
- no-store 才是真正的不进行缓存。

### 指定缓存期限和认证的指令
### max-age
> Cache-Control: max-age=604800

客户端：如果缓存没有超过一周，就把它给我。
服务器：一周内不必向我确定，直接支配该缓存返回。

当客户端发送请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间数值更小，那么客户端就接受缓存的资源。
另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。

当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性在做确定，而 max-age 数值代表资源保存为缓存的最长时间。

应用 HTTP/1.1 版本的缓存服务器余姚同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器情况却相反，max-age 指令会被忽略掉。

#### s-maxage
> Cache-Control: s-maxage=604800

s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说对向同一用户重复返回响应的服务器来说，这个指令没有任何作用。

另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。

#### min-fresh
> Cache-Control: min-fresh=60

min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。

客户端：这个缓存过了 60 秒之后还算新的吗。

#### max-stale 
使用 max-stale 可指示缓存资源，即使过期了也照常接收。

如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中制定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。


## Connection
Connection 首部字段具备如下两个作用：
1. 控制不在转发给代理的首部字段
2. 管理持久连接

### 控制不在转发给代理的首部字段
> Connection: 不再转发的首部字段名

在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不在转发给代理的首部字段（即 Hop-by-hop 首部）。

### 管理持久连接
> Connection: close

HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器想明确断开连接时，则指定 Connection 首部字段的值为 Close。

> Connection: Keep-Alive

HTTP/1.1 之前的 HTTP 版本默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

## Date 
首部字段 Date 表明创建 HTTP 报文的日期和时间。

## Pragma
Pragma 是 HTTP/1.1 之前的版本历史遗留字段，仅作为 HTTP/1.0 的向后兼容而定义。

> Pragma: no-cache

该首部字段属于通用首部字段，但只用于客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。
所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。

> Cache-Control: no-cache
> Pragma: no-cache

## Trailer
首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

HTTP/1.1 200 OK
Date: Tue, 03 Jul 2012 04:40:56 GMT
Content-Type: text/html
...
Transfer-Encoding: chunked
Trailer: Expires
CRLF
...（报文主体）...
0
Expires: Tue, 28 Sep 2004 23:59:59 GMT

以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。

## Transfer-Encoding
首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。

HTTP/1.1 的传输编码方式仅对分块传输编码有效。

## Upgrade
首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

客户端：
GET /index.htm HTTP/1.1
Upgrade: TLS/1.0
Connection: Upgrade

服务器：
HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connection: Upgrade

上述用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段的对应关系，Connection 的值被指定为 Upgrade。
Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还要额外指定 Connection: Upgrade。

对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。

## Via
使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。

报文经过代理和网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。

首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。

客户端：
GET / HTTP/1.1

代理A：
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp(Squid/3.1)

代理B：
GET / HTTP/1.1
Via: 1.0 gw.hackr.jp(Squid/3.1), 1.1 a1.example.com(Squid/2.7)

上述用例中，在经过代理服务器A时，Via 首部附加了 “1.0 gw.hackr.jp(Squid/3.1)”这样的字符串值。行头的 1.0 是指接受请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器B时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。

Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。

## Warning
HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。

Warning 首部的格式如下。最后的日期时间可以省略。
> Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])

**警告码**
- 110
- 111
- 112
- 113
- 199
- 214
- 299


---
请求首部字段

## Accept
Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可以使用 type/subtype 这个形式，一次指定多种媒体类型。

> Accept: text/html,application/xhtml+xml,application/xml;q=0.3

若想给显示额媒体类型增加优先级，则使用 q= 来额外表示权重值，用分号（;）分隔。权重值 q 的范围是 0 ~ 1，（可精确到小数点后三位）。不指定权重时，权重默认为 1。

## Accept-Charset
Accept-Charset 首部字段可以用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可以使用 q 来进行加权重。

> Accept-Charset: iso-8859-5,unicode-1-1;q=0.8

## AcceExpectationpt-Encoding
Accept-Encoding 首部字段用来告诉服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。

> Accept-Encoding: gzip, deflate

## Accept-Language
首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集，以及相对优先级。

> Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3

## Authorization
首部字段 Authorization 用来告知服务器，用户代理的认证信息。若不符合，服务器返回 401 状态码。

> Authorization: Basic dw...

## Expect
客户端使用首部 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。

> Expect: 100-continue

## Form
首部字段 Form 用来告知服务器使用用户代理的用户的电子邮件地址。

> Form: info@gap.jp

## Host
首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范中是唯一一个必须包含在请求内的首部字段。

> Host: www.hackr.jp

首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。

请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设置主机名，那直接发送空值即可。

## If-Match
只有 If-Match 的字段跟 ETag 值匹配一致时，服务器才会接受请求。否则，返回 412 Precondition Failed。

> If-Match: "123456"

还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将忽略 ETag 的值，只要资源存在就处理请求。

## If-Modified-Since
如果在 If-Modified-Since 字段指定的日期后，资源发生了修改，服务器才会接受请求。否则，返回 304 Not Modified。

> If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT

If-Modified-Since 用于确定代理或客户端拥有本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。

## If-None-Match
只有 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 的作用相反。

> If-None-Match: "123456"

## If-Range
If-Range 配合 If-Match 使用，它告知服务器若指定的 If-Range 字段值（Etag 或者时间）和请求资源的 ETag 值或时间一致时，作为范围请求处理。反之，返回全体资源。

If-Match: "123456"
If-Range: bytes=0-5000

## If-Unmodified-Since
如果服务器在指定时间后未发生修改，则处理请求。否则，返回 412 Precondition Failed

> If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT

## Max-Forwards
通过 TRACE 方法或者 OPTION 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器再往下一个服务器转发请求时，Max-Forwards 的值减去 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。

## Proxy-Authorization
接收到从代理服务器发来的认证咨询时，客户端会发送包含首部字段 Proxy-Authorizition 的请求，以告知服务器认证需要的信息。

> Proxy-Authorization: Basic dGlwOjkpNLAGfFY5

## Range

> Range: bytes=5001-10000

对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。

接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。

## Referer

> Referer: https://www.baidu.com

首部字段 Referer 会告知服务器请求的原始资源的 URI。

客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI 时，出于安全性的考虑时，也可以不发送该首部字段。

另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。

## TE

> TE: gzip, deflate;q=0.5

首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

## User-Agent

> User-Agent: Mozilla/5.0(Windows NT 6.1; WOW64; rv:13.0)

首部字段 User-Agent 会将创建请求额浏览器和用户代理名称等信息传送到服务器。


----
响应首部字段

## Accept-Ranges
首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。

可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之指定为 none。

> Accept-Ranges: bytes

## Age
首部字段 Age 能告知客户端，源服务器在多久之前创建了响应。字段值的单位为秒。

若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。

> Age: 600

## ETag
首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一标识的方式。服务器会为每份资源分配对于的 ETag 值。

另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法，而仅仅是由服务器来分配。

> ETag: "823423f"

- 强 ETag：实体发生多么细微额变化都会改变其值。
- 弱 ETag：只有资源本体发生变化才会改变其值，并附加 W/。

## Location
使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。

基本上，该字段会配合 3xx：Redirection 的响应，提供重定向 URI。

几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源访问。

> Location: https://www.baidu.com

