## HTTP协议

#### 简介

HTTP 协议定义 Web 客户端如何从 Web 服务器 请求 Web 界面，以及服务器如何把 Web 界面传送给客户端。

HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包括请求的方法，URL，协议版本，请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本，成功或者错误代码，服务器信息，响应头部和响应数据。

HTTP 是不保存状态的协议，即无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。这也是 Cookie 技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保存 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务器识别客户端身份状态的标识。



#### TCP/IP 协议族

为了更好的了解 HTTP 协议，必须先了解一下 TCP/IP 协议族。TCP/IP 协议族是 Internet 最基本的协议，HTTP 协议是它的一个子集。TCP/IP 协议族按层次划分为以下四层：

- **应用层**
  - 应用层规定了向用户提供应用服务时的通信的协议，TCP/IP 协议族内预存了各类通用的应用服务协议。
  - 常见：FTP（文件传输协议）、DNS（域名系统）、HTTP（超文本传输协议）。
- **传输层**
  - 传输层提供处于网络连接中两台计算机之间数据传输所用的协议。
  - TCP（传输控制协议）、UDP（用户数据报协议）。
  - TCP 协议是全双工的，即发送数据和接收数据是同步进行的，就好像我们打电话，说话的同时也能听见。TCP 协议在建立和断开连接时有三次握手和四次挥手，因此在传输过程中更加稳定可靠，但同时也没 UDP 那么高效了。
  - UDP 协议是面向无连接的，也就是说在正式传递数据之前不需要建立连接。UDP 协议不保证有序且不丢失的传递到对端，也就是说不够稳定，但也因此比 TCP 更加高效和轻便。
- **网络层**
  - 网络层规定了数据通过怎样的传输路线达到对方计算机（IP协议等）。
  - 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条最优传输线路。类似导航的作用。
- **链路层**
  - 用来处理连接网络的硬件部分，包括控制操作系统，硬件设备驱动，网卡，以及光纤等物理可见设备。硬件上的范围均在链路层的作用范围内。

![](.\img\网络原理图.jpg)

​	发送端在层和层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层和层之间传输数据时，每经过一层时会把对应的首部去掉。



#### 串行连接、持久连接、管道化持久连接、HTTP/2.0 多路复用

- **串行连接：**HTTP 有无连接的特性，即每次连接只能处理一个请求，收到响应后立即断开连接。HTTP/1.0 版本（称为串行连接、短连接、短轮询）中每次 HTTP 通信后都要断开 TCP 连接，所以每个新的 HTTP 请求都需要建立一个新的连接。但在现在网站动则几十条 HTTP 请求的情况下，很容易达到浏览器的请求上限，并且每次请求都建立新的 TCP 连接（三次握手，四次挥手）极大的增加了通信开销**。**
- **持久连接：**为了解决这个问题，有人提出了持久连接（也叫长连接，长轮询）。一定时间内，同一域名下的 HTTP，只要两端都没有提出断开连接，则持久保存 TCP 连接状态，其他请求可以复用这个连接通道。HTTP/1.1 实现并默认了所有连接都是持久连接，这样客户端发起多个 HTTP 请求时就减少了 TCP 握手挥手造成的网络资源和通信时间的浪费。但是持久连接采用阻塞模式，下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着（就是常说的线头阻塞）。
- **管道化持久连接：**管道化则可以不用等到响应返回而发送下个请求并按顺序返回响应，现代浏览器并未默认开启管道化。
- **HTTP/2.0 多路复用：**每个 HTTP 请求都有一个序列标识符，这样浏览器可以并发多个请求，服务器接收到数据后，再根据序列标识符重新排序成不同的请求报文，而不会导致数据错乱。同样，服务端也可以并发返回多个响应给浏览器，浏览器收到后根据序列标识符重新排序并归入各自请求的响应报文。并且同一个域名下的所有请求都复用同一个 TCP 连接，极大增加了服务器处理并发的上限。
- **WebSocket：**WebSocket 是 HTML5 提出的一种客户端和服务端通讯的全双工协议，由客户端发起请求，建立简介后不仅客户端可以主动向服务器发送请求，服务端也可以主动向客户端推送信息。

![](.\img\连接方式.jpg)



#### URI

HTTP 协议使用 URI 定位互联网上的资源。

- URI（Universal Resource Identifier：统一资源标识符）
- URL（Universal Resource Locator：统一资源定位符）
- URN（Universal Resource Name：统一资源名称）

URI：www.juejin.cn/a.png

URL：www.juejin.cn

URN：a.png

URI = URL + URN



#### HTTP 版本

##### HTTP/1.0

最早的 HTTP 只是使用在一些简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的 TCP 连接，收到响应之后立即断开连接。

##### HTTP/1.1

- HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match等。
- HTTP/1.1 允许范围请求，即在请求头加入 Range 头部。
- HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部，以区分同一个物理主机中的不同虚拟主机的域名。
- HTTP/1.1 默认开启之久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。

##### HTTP/2.0

在 HTTP/2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。帧代表数据传输的最小单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。

- **新的二进制格式：**HTTP/1.x 的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景很多。二进制则不同，只识别 0 和 1 的组合。基于这种考虑 HTTP/2.0 的协议解析采用二进制格式，方便且强大。
- **多路复用：**HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其他连接的正常执行，极大的提高传输性能。
- **头部压缩：**HTTP/1.x 的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields，即避免了重复头部的传输，又减少了需要传输的大小。
- **服务端推送：**这里的服务端推送指把客户端所需要的 css/js/img 等资源伴随着 index.html 一起发送到客户端，省去了客户端重新请求的步骤（从缓存中取）。

##### HTTP/3.0

HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。反而对于 HTTP/1.0 来说，可以开启多个 TCP 连接，出现丢包反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。出现包阻塞的原因是因为底层 TCP 协议导致的问题，但是修改 TCP 协议是不现实的问题。所以 Google 基于 UDP 协议推出了一个 QUIC 协议，并使用在 HTTP/3.0 上。

QUIC 基于 UDP，但是 UDP 本身存在不稳定性等诸多问题，所以 QUIC 在 UDP 的基础上新增了很多功能，比如多路复用，0-RTT，使用 TLS1.3 加密，流量控制，有序交付，重传等等功能。

- **避免包阻塞：**多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题，TCP 需要等待该包重传后，才能继续传输其他流的数据包。但在基于 UDP 的 QUIC 协议中，不同的流之前的数据传输实现了互相独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。
- **快速重启会话：**普通基于 TCP 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用移动网络时，会改变本身的 ip，这就导致 TCP 连接必须重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。



#### HTTP 报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。客户端的 HTTP 报文叫请求报文，服务端的 HTTP 报文叫响应报文。

##### 请求报文

请求报文是由请求行（请求方法，协议版本），请求首部（请求URI，客户端信息等）和内容实体（请求体）构成。

![](.\img\请求报文.jpg)

##### 响应报文

响应报文是由状态行（协议版本、状态码）、响应首部（服务器名称、资源标识等）和内容实体（服务端返回的资源信息）构成。



#### 请求方法

- get：get 方法一般用来获取服务器资源。
- post：post 方法一般用于传输实体主体。
- put：put 方法一帮用于传输对象。
- delete：delete 方法用于删除数据。
- head：head 方法用于获取报文首部，不返回报文主体。
- options：options 方法用于查询请求 URI 资源支持的方法。



#### 状态码

| 2XX  | 成功（表示被正常处理了）                         |
| ---- | ------------------------------------------------ |
| 200  | OK，表示正确处理。                               |
| 204  | No content，表示请求成功，但响应报文没有响应体。 |
| 206  | Partial Content，进行范围请求成功。              |

| 3XX  | 表明浏览器要执行特殊处理                                     |
| ---- | ------------------------------------------------------------ |
| 301  | moved premanetly，永久重定向，表示资源已被分配了新的 URL。   |
| 302  | found，临时重定向，表示资源临时被分配了新的 URL。            |
| 303  | see other，表示资源存在着另一个  URL，应用 GET 方法获取资源。 |
| 304  | not modified，表示服务器允许访问资源，但请求为满足条件的情况（与重定向无关）。 |
| 307  | temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。 |

| 4XX  | 客户端错误                                                   |
| ---- | ------------------------------------------------------------ |
| 400  | bad request，请求报文存在语法错误。                          |
| 401  | unauthorized，表示发送的请求需要有通过 HTTP 认证的信息。     |
| 403  | forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述。 |
| 404  | not found，表示在服务器上没有找到请求的资源。                |

| 5XX  | 服务器错误                                                   |
| ---- | ------------------------------------------------------------ |
| 500  | internal server error，表示服务器端在执行请求时发生错误。    |
| 501  | not implemented，表示服务器不支持当前请求所需要的某个功能。  |
| 503  | service unavailable，表明服务器暂时处于超负荷或正在停机维修，无法处理请求。 |



#### 首部字段

| 通用首部          | 作用（请求报文和响应报文都可能使用）                         |
| ----------------- | ------------------------------------------------------------ |
| Cache-Control     | 控制缓存的行为：no-cache（强制向服务器再次验证），no-store（不做任何缓存），max-age=1111（资源可缓存的最大时间，单位秒），public（客户端，代理服务器都利用缓存），private（代理服务器不可用缓存）。 |
| Connection        | 浏览器想要有限使用的连接类型：keep-alive（开启持久连接），close（关闭）。 |
| Date              | 创建报文时间。                                               |
| Pragma            | 只用于请求报文，客户端要求中间服务器不返回缓存的资源。       |
| Via               | 代理服务器相关信息，每经过一个代理服务器就会添加相关信息，用逗号分割。 |
| Transfer-Encoding | 传输编码方式：chunked 分块传输。                             |
| Upgrade           | 要求客户端使用升级的协议，需配合 Connection：Upgrade 一起使用 |
| Warning           | 缓存相关问题                                                 |

| 请求首部            | 作用（请求报文专用）                                         |
| ------------------- | ------------------------------------------------------------ |
| Accept              | 能正确接收到的媒体类型：application/json，text/plain         |
| Accept-Charset      | 能正确接收到的字符集：unicode-1-1                            |
| Accept-Encoding     | 能正确接受的编码格式列表：gzip，deflate                      |
| Accept-Language     | 能正确接受的语言列表：zh-cn                                  |
| Authorization       | 客户端认证信息                                               |
| Cookie              | 发送给服务器的 Cookie 信息                                   |
| Expect              | 期待服务器的指定行为                                         |
| Form                | 请求方邮箱地址                                               |
| Host                | 服务器的域名，用于区分单台服务器多个域名的虚拟主机，是 HTTP/1.1 唯一必须包含的字段。 |
| if-Match            | 两端资源标记比较，只有判断条件为真服务端才会接受请求         |
| if-Modified-Since   | 本地资源未修改返回 304（比较时间）                           |
| if-None-Match       | 本地资源未修改返回 304（比较标记）                           |
| User-Agent          | 客户端信息                                                   |
| Max-Forwards        | 限制可被代理及网关转发的次数                                 |
| Proxy-Authorization | 向代理服务器发送验证信息                                     |
| Range               | 请求某个内容的一部分，配和 If-Range 使用                     |
| Referer             | 请求发起界面的原始 URI                                       |
| TE                  | 传输编码方式                                                 |

| 响应首部          | 作用（响应报文专用）                                  |
| ----------------- | ----------------------------------------------------- |
| Accept-Ranges     | 告知客户端服务器是否可接受范围请求，是 bytes，否 none |
| Age               | 资源在代理缓存中存在的时间                            |
| ETag              | 资源标识，资源发生变化是标识也会发生改变              |
| Location          | 客户端重定向到某个 URL                                |
| Proxy-Authenicate | 向代理服务器发送验证信息                              |
| Server            | 服务器名字：Apache Nginx                              |
| WWW-Authenticate  | 获取资源需要的认证方案                                |
| set-Cookie        | 需要存在客户端的信息，一般用于识别用户身份            |

| 实体首部         | 作用（补充请求报文或响应报文相关信息） |
| ---------------- | -------------------------------------- |
| Allow            | 资源的正确请求方式                     |
| Content-Encoding | 内容的编码格式：gzip deflate           |
| Content-Language | 内容使用的语言：zh-CN                  |
| Content-Length   | 实体主题的大小                         |
| Content-Location | 返回数据的备用地址                     |
| Content-MD5      | Base64 加密格式的内容，MD5 检验值      |
| Content-Range    | 响应主体的内容范围                     |
| Content-Type     | 内容的媒体类型                         |
| Expires          | 内容的过期时间                         |
| Last_modified    | 内容的最后修改时间                     |



#### 简单请求和复杂请求

浏览器发送 CORS 请求（跨域请求时），会将请求分为简单请求与复杂请求。

在我们日常生活中，常用的**简单请求**可以将其归为以下几点：

- 请求方法只能是 head，get，post
- 无自定义请求头
- Context-Type 只能是：text/plain，multipart/form-data，application/x-www-form-urlencoded

**复杂请求：**

- put，delete 方法的 ajax 请求
- 发送 json 格式的 ajax 请求
- 带自定义头的 ajax 请求

**简单请求流程：**

浏览器检查到是 cors 请求，添加一个 origin 字段 -->  服务端收到后相应的处理（对比 origin，服务端判断这个源是否接受），返回结果给浏览器  -->  浏览器检查响应头是否允许跨域信息 -->  允许，就展示结果。不允许，浏览器抛出相应的错误信息。

**复杂请求流程：**

复杂请求在发送请求时，如果是 cors 请求，浏览器会预先发送一个 option 请求。浏览器这种行为被称之为预检请求。



#### web 服务器

这里不关心服务器是 Apache 还是 Nginx，而是在于服务器的作用。一台服务器可以作为源服务器，也可以作为中转服务器，甚至可以在一台服务器上搭建多个不同域名的网站。



#### 虚拟主机

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 web 站点。利用虚拟主机的功能，可以在一台物理服务器（一个 IP 地址）上虚拟出多个主机，每个主机映射一个独立的域名。因此，当用户访问一个域名时，DNS 域名系统会将其解析成 IP 地址，根据 IP 找到物理服务器，然后通过请求首部的 HOST 字段确认对应的虚拟主机。



#### 代理服务器

代理服务器就是客户端和服务端之间的中间商，即 HTTP 请求通过代理服务器转发给服务器，再将服务器的响应返回给客户端的行为。代理服务器可以用来作为缓存服务器，也可以用来隐藏用户身份（正向代理）或者服务器身份（反向代理），增加安全性。

- 所谓正向代理，是客户为了从源服务器中取得内容，由客户端向代理服务器发出请求，并指定目标访问服务器，然后，代理服务器向源服务器转交需求，并将获得的内容返回给客户端。需要注意的是，在正向代理过程中隐藏了真正请求的客户端，及服务端不知道正式请求客户是谁。
- 所谓反向代理，是客户端向反向代理发出请求，反向代理服务器收到需求后判断请求走向何处，然后再将结果反馈给客户端。同样需要注意的是，在反向代理过程中，隐藏了内部服务器的信息，用户不需要直到具体哪一台服务器提供的服务，只要直到反向代理服务器是谁就好了，我们甚至可以把反向代理服务器看成真正的服务器。这种形式的代理通常被用作实现负载均衡，比如 Nginx 就是一种出色的反向代理服务器。
- 反向代理解决跨域问题：在前后端分离项目中，经常遇到跨域问题。因为项目自身启动本地服务是需要占用一个端口（如：localhost:8080），所以必然会产生跨域问题（因为本地服务端口和服务器端口是不同的）。在使用 webpack 做构建工具时，经常会用 proxyTable 代理实现跨域。之所以出现跨域是因为浏览器由同源策略的限制，但服务器是没有同源策略的限制的。当我们本地服务（假设：http://localhost:8080）要请求目标服务器（假设：http://target.com）的资源的时候，我们不直接请求 target.com，而是请求本地服务自身 http://localhost:8080 （这时候是同源请求，不存在跨域），本地代理服务再将接口转发给 target.com（注意这时候是两个服务器直接的通信了，而不是客户端和服务器通信，所以不存在跨域），本地服务获取到目标服务器的响应数据之后通过再代理伪装成本地服务请求的返回值返回给客户端。



#### 缓存服务器

缓存服务器指的是将需要频繁范文的网络内容存放在离用户较近，访问速度更快的服务器中，以提高内容访问速度的一种技术。缓存服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 HTTP 请求，经过处理（比如权限验证，缓存匹配等），再将请求转发到服务器。



#### HTTPS

HTTP 本身没有任何保密性，所以 HTTP 传输的数据相当于都是在网上以明文的方式裸奔。为了解决这个问题，出现了各种加密手段：

- 对称加密：唯一密钥 key 可用来加密也可以用来解密。这样的加密需要双方都拥有密钥 key，如果第一次传输密钥被第三方截获就完蛋。
- 非对称加密：服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公獒可以自由发布供任何人使用。客户端的铭文通过公钥加密后的密文需要使用私钥解密。

- SSL：首先需要从证书认证机构申请证书（证书中含有证书签名和服务端公钥 key1）。在客户端发起 HTTP 请求时，服务端将证书发送给客户端。客户端认证证书的真伪，然后解密出服务端公钥 key1，用公钥加密自己生成的对称加密密钥 key2 并传给服务端，最后利用 key2 加密进行通信。安全性方面，私钥是机构的，可以避免第三方伪装证书。并且就算得到了服务端公钥，也无法解密出公钥 key1 加密过的对称加密密钥 key2。

HTTPS 基于 HTTP 协议，通过 SSL 或者 TLS（可以看作 SSL 3.0）提供加密处理数据，验证对方身份以及数据完整性保护。特点如下：

- 内容加密：采用混合加密技术，中间者无法直接查看明文内容。
- 验证身份：通过证书认证客户端访问的是自己的服务器。
- 保护数据完整性：防止传输内容被中间人冒充或篡改。

**HTTPS 和 HTTP 的区别如下：**

- HTTPS 协议需要用到 CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
- HTTP 协议运行在 TCP 之上，所有的传输内容都是明文，HTTPS 运行在 SSL/TLS 上，SSL/TLS 运行在 TCP 之上，所以传输的内容都经过了加密。
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTP 的连接很简单，是无状态的。HTTPS 协议是由 HTTP + SSL 协议构建的可进行加密传输，身份认证的网络协议，可以有效地防止运营商劫持，解决了防劫持的一个大问题，比 HTTP 协议安全。



#### WEB 安全规范

##### XSS 攻击

XSS （跨脚本攻击），是利用 html 可以执行<font color=red>脚本</font>的特性，想尽办法将脚本注入界面的攻击手段。XSS 攻击有两种，一种是通过修改浏览器 URL 导致脚本被注入到界面，另一种是通过输入框将脚本注入数据库。前面一种会被 chrome 浏览器自动防御攻击（但最好手动也进行防御），后面一种则需要我们手动防御，推荐使用 ’xss‘ 库的白名单过滤防御对象。

##### CSRF 攻击

CSRF（跨站请求伪造）

##### 点击劫持

##### 中间人攻击
